/*
 * List
 *
 *  Created on: May 10, 2017
 *      Author: zollder
 */

#ifndef LIST_H_
#define LIST_H_

#include "exceptions/InvalidPositionException.h"
#include "exceptions/EmptyContainerException.h"
#include "exceptions/BoundaryViolationException.h"

#include "stdio.h"
#include <vector>

using namespace::std;

template <class T>
class List {
	protected:
		struct Node {
			T value;
			Node* prev;
			Node* next;
			Node(const T& val = T(), Node* prv = nullptr, Node* nxt = nullptr)
				: value(val), prev(prv), next(nxt) {}
		};
		typedef Node* NodePtr;

	public:
		class Position {
			private:
				NodePtr node;

			public:
				Position(NodePtr n = nullptr) {
					node = n;
				}

				~Position() {
					// position node is deleted upon list cleanup
				}

				T& getValue() {
					if (node == nullptr) {
						throw InvalidPositionException("Null node");
					} else {
						return node->value;
					}
				}

				bool isNull() {
					return node == nullptr;
				}

				friend class List<T>;
		};

	private:
		int sz;

	protected:
		NodePtr header;
		NodePtr trailer;

		NodePtr getNodePtr(const Position& position) const throw (InvalidPositionException);

	public:
		// TODO: add copy constructor and assignment operator
		List() {
			sz = 0;
			header = new Node;
			trailer = new Node;
			header->next = trailer;
			header->prev = nullptr;
			trailer->prev = header;
			trailer->next = nullptr;
		}

		~List() {
			clear();
			delete header;
			delete trailer;
		}

		int size() const;
		bool isEmpty() const;
		bool isFirst(const Position& position) const throw(InvalidPositionException);
		bool isLast(const Position& position) const throw(InvalidPositionException);

		Position first() const throw (EmptyContainerException);
		Position last() const throw (EmptyContainerException);
		Position before(const Position& position) const throw (InvalidPositionException, BoundaryViolationException);
		Position after(const Position& position) const throw (InvalidPositionException, BoundaryViolationException);

		Position insertFirst(const T& element);
		Position insertLast(const T& element);
		Position insertBefore(const Position& position, const T& element);
		Position insertAfter(const Position& position, const T& element);

		void addAll(const vector<T> &values);
		void replace(const Position& position, const T& element);
		void swap(const Position& position1, const Position& position2) const throw (InvalidPositionException);
		void remove(const Position& position) throw (InvalidPositionException);
		void clear();
		void print();
};

#endif /* LIST_H_ */
